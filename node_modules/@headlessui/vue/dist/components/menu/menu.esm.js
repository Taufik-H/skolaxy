import { extends as _extends } from '../../_virtual/_rollupPluginBabelHelpers.js';
import { defineComponent, ref, provide, computed, onMounted, onUnmounted, watchEffect, nextTick, inject } from 'vue';
import { match } from '../../utils/match.esm.js';
import { render, Features } from '../../utils/render.esm.js';
import { Keys } from '../../keyboard.esm.js';
import { useId } from '../../hooks/use-id.esm.js';
import { useWindowEvent } from '../../hooks/use-window-event.esm.js';
import { dom } from '../../utils/dom.esm.js';
import { useOpenClosedProvider, State, useOpenClosed } from '../../internal/open-closed.esm.js';
import { useResolveButtonType } from '../../hooks/use-resolve-button-type.esm.js';
import { calculateActiveIndex, Focus } from '../../utils/calculate-active-index.esm.js';
import { useTreeWalker } from '../../hooks/use-tree-walker.esm.js';

var MenuStates;

(function (MenuStates) {
  MenuStates[MenuStates["Open"] = 0] = "Open";
  MenuStates[MenuStates["Closed"] = 1] = "Closed";
})(MenuStates || (MenuStates = {}));

function nextFrame(cb) {
  requestAnimationFrame(function () {
    return requestAnimationFrame(cb);
  });
}

var MenuContext = /*#__PURE__*/Symbol('MenuContext');

function useMenuContext(component) {
  var context = inject(MenuContext, null);

  if (context === null) {
    var err = new Error("<" + component + " /> is missing a parent <Menu /> component.");
    if (Error.captureStackTrace) Error.captureStackTrace(err, useMenuContext);
    throw err;
  }

  return context;
}

var Menu = /*#__PURE__*/defineComponent({
  name: 'Menu',
  props: {
    as: {
      type: [Object, String],
      "default": 'template'
    }
  },
  setup: function setup(props, _ref) {
    var slots = _ref.slots,
        attrs = _ref.attrs;
    var menuState = ref(MenuStates.Closed);
    var buttonRef = ref(null);
    var itemsRef = ref(null);
    var items = ref([]);
    var searchQuery = ref('');
    var activeItemIndex = ref(null);
    var api = {
      menuState: menuState,
      buttonRef: buttonRef,
      itemsRef: itemsRef,
      items: items,
      searchQuery: searchQuery,
      activeItemIndex: activeItemIndex,
      closeMenu: function closeMenu() {
        menuState.value = MenuStates.Closed;
        activeItemIndex.value = null;
      },
      openMenu: function openMenu() {
        return menuState.value = MenuStates.Open;
      },
      goToItem: function goToItem(focus, id) {
        var nextActiveItemIndex = calculateActiveIndex(focus === Focus.Specific ? {
          focus: Focus.Specific,
          id: id
        } : {
          focus: focus
        }, {
          resolveItems: function resolveItems() {
            return items.value;
          },
          resolveActiveIndex: function resolveActiveIndex() {
            return activeItemIndex.value;
          },
          resolveId: function resolveId(item) {
            return item.id;
          },
          resolveDisabled: function resolveDisabled(item) {
            return item.dataRef.disabled;
          }
        });
        if (searchQuery.value === '' && activeItemIndex.value === nextActiveItemIndex) return;
        searchQuery.value = '';
        activeItemIndex.value = nextActiveItemIndex;
      },
      search: function search(value) {
        searchQuery.value += value.toLowerCase();
        var match = items.value.findIndex(function (item) {
          return item.dataRef.textValue.startsWith(searchQuery.value) && !item.dataRef.disabled;
        });
        if (match === -1 || match === activeItemIndex.value) return;
        activeItemIndex.value = match;
      },
      clearSearch: function clearSearch() {
        searchQuery.value = '';
      },
      registerItem: function registerItem(id, dataRef) {
        // @ts-expect-error The expected type comes from property 'dataRef' which is declared here on type '{ id: string; dataRef: { textValue: string; disabled: boolean; }; }'
        items.value.push({
          id: id,
          dataRef: dataRef
        });
      },
      unregisterItem: function unregisterItem(id) {
        var nextItems = items.value.slice();
        var currentActiveItem = activeItemIndex.value !== null ? nextItems[activeItemIndex.value] : null;
        var idx = nextItems.findIndex(function (a) {
          return a.id === id;
        });
        if (idx !== -1) nextItems.splice(idx, 1);
        items.value = nextItems;

        activeItemIndex.value = function () {
          if (idx === activeItemIndex.value) return null;
          if (currentActiveItem === null) return null; // If we removed the item before the actual active index, then it would be out of sync. To
          // fix this, we will find the correct (new) index position.

          return nextItems.indexOf(currentActiveItem);
        }();
      }
    };
    useWindowEvent('mousedown', function (event) {
      var _dom, _dom2, _dom3;

      var target = event.target;
      var active = document.activeElement;
      if (menuState.value !== MenuStates.Open) return;
      if ((_dom = dom(buttonRef)) == null ? void 0 : _dom.contains(target)) return;
      if (!((_dom2 = dom(itemsRef)) == null ? void 0 : _dom2.contains(target))) api.closeMenu();
      if (active !== document.body && (active == null ? void 0 : active.contains(target))) return; // Keep focus on newly clicked/focused element

      if (!event.defaultPrevented) (_dom3 = dom(buttonRef)) == null ? void 0 : _dom3.focus({
        preventScroll: true
      });
    }); // @ts-expect-error Types of property 'dataRef' are incompatible.

    provide(MenuContext, api);
    useOpenClosedProvider(computed(function () {
      var _match;

      return match(menuState.value, (_match = {}, _match[MenuStates.Open] = State.Open, _match[MenuStates.Closed] = State.Closed, _match));
    }));
    return function () {
      var slot = {
        open: menuState.value === MenuStates.Open
      };
      return render({
        props: props,
        slot: slot,
        slots: slots,
        attrs: attrs,
        name: 'Menu'
      });
    };
  }
});
var MenuButton = /*#__PURE__*/defineComponent({
  name: 'MenuButton',
  props: {
    disabled: {
      type: Boolean,
      "default": false
    },
    as: {
      type: [Object, String],
      "default": 'button'
    }
  },
  render: function render$1() {
    var _dom4;

    var api = useMenuContext('MenuButton');
    var slot = {
      open: api.menuState.value === MenuStates.Open
    };
    var propsWeControl = {
      ref: 'el',
      id: this.id,
      type: this.type,
      'aria-haspopup': true,
      'aria-controls': (_dom4 = dom(api.itemsRef)) == null ? void 0 : _dom4.id,
      'aria-expanded': this.$props.disabled ? undefined : api.menuState.value === MenuStates.Open,
      onKeydown: this.handleKeyDown,
      onKeyup: this.handleKeyUp,
      onClick: this.handleClick
    };
    return render({
      props: _extends({}, this.$props, propsWeControl),
      slot: slot,
      attrs: this.$attrs,
      slots: this.$slots,
      name: 'MenuButton'
    });
  },
  setup: function setup(props, _ref2) {
    var attrs = _ref2.attrs;
    var api = useMenuContext('MenuButton');
    var id = "headlessui-menu-button-" + useId();

    function handleKeyDown(event) {
      switch (event.key) {
        // Ref: https://www.w3.org/TR/wai-aria-practices-1.2/#keyboard-interaction-13
        case Keys.Space:
        case Keys.Enter:
        case Keys.ArrowDown:
          event.preventDefault();
          event.stopPropagation();
          api.openMenu();
          nextTick(function () {
            var _dom5;

            (_dom5 = dom(api.itemsRef)) == null ? void 0 : _dom5.focus({
              preventScroll: true
            });
            api.goToItem(Focus.First);
          });
          break;

        case Keys.ArrowUp:
          event.preventDefault();
          event.stopPropagation();
          api.openMenu();
          nextTick(function () {
            var _dom6;

            (_dom6 = dom(api.itemsRef)) == null ? void 0 : _dom6.focus({
              preventScroll: true
            });
            api.goToItem(Focus.Last);
          });
          break;
      }
    }

    function handleKeyUp(event) {
      switch (event.key) {
        case Keys.Space:
          // Required for firefox, event.preventDefault() in handleKeyDown for
          // the Space key doesn't cancel the handleKeyUp, which in turn
          // triggers a *click*.
          event.preventDefault();
          break;
      }
    }

    function handleClick(event) {
      if (props.disabled) return;

      if (api.menuState.value === MenuStates.Open) {
        api.closeMenu();
        nextTick(function () {
          var _dom7;

          return (_dom7 = dom(api.buttonRef)) == null ? void 0 : _dom7.focus({
            preventScroll: true
          });
        });
      } else {
        event.preventDefault();
        event.stopPropagation();
        api.openMenu();
        nextFrame(function () {
          var _dom8;

          return (_dom8 = dom(api.itemsRef)) == null ? void 0 : _dom8.focus({
            preventScroll: true
          });
        });
      }
    }

    return {
      id: id,
      el: api.buttonRef,
      type: useResolveButtonType(computed(function () {
        return {
          as: props.as,
          type: attrs.type
        };
      }), api.buttonRef),
      handleKeyDown: handleKeyDown,
      handleKeyUp: handleKeyUp,
      handleClick: handleClick
    };
  }
});
var MenuItems = /*#__PURE__*/defineComponent({
  name: 'MenuItems',
  props: {
    as: {
      type: [Object, String],
      "default": 'div'
    },
    "static": {
      type: Boolean,
      "default": false
    },
    unmount: {
      type: Boolean,
      "default": true
    }
  },
  render: function render$1() {
    var _api$items$value$api$, _dom9;

    var api = useMenuContext('MenuItems');
    var slot = {
      open: api.menuState.value === MenuStates.Open
    };
    var propsWeControl = {
      'aria-activedescendant': api.activeItemIndex.value === null ? undefined : (_api$items$value$api$ = api.items.value[api.activeItemIndex.value]) == null ? void 0 : _api$items$value$api$.id,
      'aria-labelledby': (_dom9 = dom(api.buttonRef)) == null ? void 0 : _dom9.id,
      id: this.id,
      onKeydown: this.handleKeyDown,
      onKeyup: this.handleKeyUp,
      role: 'menu',
      tabIndex: 0,
      ref: 'el'
    };
    var passThroughProps = this.$props;
    return render({
      props: _extends({}, passThroughProps, propsWeControl),
      slot: slot,
      attrs: this.$attrs,
      slots: this.$slots,
      features: Features.RenderStrategy | Features.Static,
      visible: this.visible,
      name: 'MenuItems'
    });
  },
  setup: function setup() {
    var api = useMenuContext('MenuItems');
    var id = "headlessui-menu-items-" + useId();
    var searchDebounce = ref(null);
    useTreeWalker({
      container: computed(function () {
        return dom(api.itemsRef);
      }),
      enabled: computed(function () {
        return api.menuState.value === MenuStates.Open;
      }),
      accept: function accept(node) {
        if (node.getAttribute('role') === 'menuitem') return NodeFilter.FILTER_REJECT;
        if (node.hasAttribute('role')) return NodeFilter.FILTER_SKIP;
        return NodeFilter.FILTER_ACCEPT;
      },
      walk: function walk(node) {
        node.setAttribute('role', 'none');
      }
    });

    function handleKeyDown(event) {
      if (searchDebounce.value) clearTimeout(searchDebounce.value);

      switch (event.key) {
        // Ref: https://www.w3.org/TR/wai-aria-practices-1.2/#keyboard-interaction-12
        // @ts-expect-error Fallthrough is expected here
        case Keys.Space:
          if (api.searchQuery.value !== '') {
            event.preventDefault();
            event.stopPropagation();
            return api.search(event.key);
          }

        // When in type ahead mode, fallthrough

        case Keys.Enter:
          event.preventDefault();
          event.stopPropagation();

          if (api.activeItemIndex.value !== null) {
            var _document$getElementB;

            var _id = api.items.value[api.activeItemIndex.value].id;
            (_document$getElementB = document.getElementById(_id)) == null ? void 0 : _document$getElementB.click();
          }

          api.closeMenu();
          nextTick(function () {
            var _dom10;

            return (_dom10 = dom(api.buttonRef)) == null ? void 0 : _dom10.focus({
              preventScroll: true
            });
          });
          break;

        case Keys.ArrowDown:
          event.preventDefault();
          event.stopPropagation();
          return api.goToItem(Focus.Next);

        case Keys.ArrowUp:
          event.preventDefault();
          event.stopPropagation();
          return api.goToItem(Focus.Previous);

        case Keys.Home:
        case Keys.PageUp:
          event.preventDefault();
          event.stopPropagation();
          return api.goToItem(Focus.First);

        case Keys.End:
        case Keys.PageDown:
          event.preventDefault();
          event.stopPropagation();
          return api.goToItem(Focus.Last);

        case Keys.Escape:
          event.preventDefault();
          event.stopPropagation();
          api.closeMenu();
          nextTick(function () {
            var _dom11;

            return (_dom11 = dom(api.buttonRef)) == null ? void 0 : _dom11.focus({
              preventScroll: true
            });
          });
          break;

        case Keys.Tab:
          event.preventDefault();
          event.stopPropagation();
          break;

        default:
          if (event.key.length === 1) {
            api.search(event.key);
            searchDebounce.value = setTimeout(function () {
              return api.clearSearch();
            }, 350);
          }

          break;
      }
    }

    function handleKeyUp(event) {
      switch (event.key) {
        case Keys.Space:
          // Required for firefox, event.preventDefault() in handleKeyDown for
          // the Space key doesn't cancel the handleKeyUp, which in turn
          // triggers a *click*.
          event.preventDefault();
          break;
      }
    }

    var usesOpenClosedState = useOpenClosed();
    var visible = computed(function () {
      if (usesOpenClosedState !== null) {
        return usesOpenClosedState.value === State.Open;
      }

      return api.menuState.value === MenuStates.Open;
    });
    return {
      id: id,
      el: api.itemsRef,
      handleKeyDown: handleKeyDown,
      handleKeyUp: handleKeyUp,
      visible: visible
    };
  }
});
var MenuItem = /*#__PURE__*/defineComponent({
  name: 'MenuItem',
  props: {
    as: {
      type: [Object, String],
      "default": 'template'
    },
    disabled: {
      type: Boolean,
      "default": false
    }
  },
  setup: function setup(props, _ref3) {
    var slots = _ref3.slots,
        attrs = _ref3.attrs;
    var api = useMenuContext('MenuItem');
    var id = "headlessui-menu-item-" + useId();
    var active = computed(function () {
      return api.activeItemIndex.value !== null ? api.items.value[api.activeItemIndex.value].id === id : false;
    });
    var dataRef = ref({
      disabled: props.disabled,
      textValue: ''
    });
    onMounted(function () {
      var _document$getElementB2, _document$getElementB3;

      var textValue = (_document$getElementB2 = document.getElementById(id)) == null ? void 0 : (_document$getElementB3 = _document$getElementB2.textContent) == null ? void 0 : _document$getElementB3.toLowerCase().trim();
      if (textValue !== undefined) dataRef.value.textValue = textValue;
    });
    onMounted(function () {
      return api.registerItem(id, dataRef);
    });
    onUnmounted(function () {
      return api.unregisterItem(id);
    });
    watchEffect(function () {
      if (api.menuState.value !== MenuStates.Open) return;
      if (!active.value) return;
      nextTick(function () {
        var _document$getElementB4;

        return (_document$getElementB4 = document.getElementById(id)) == null ? void 0 : _document$getElementB4.scrollIntoView == null ? void 0 : _document$getElementB4.scrollIntoView({
          block: 'nearest'
        });
      });
    });

    function handleClick(event) {
      if (props.disabled) return event.preventDefault();
      api.closeMenu();
      nextTick(function () {
        var _dom12;

        return (_dom12 = dom(api.buttonRef)) == null ? void 0 : _dom12.focus({
          preventScroll: true
        });
      });
    }

    function handleFocus() {
      if (props.disabled) return api.goToItem(Focus.Nothing);
      api.goToItem(Focus.Specific, id);
    }

    function handleMove() {
      if (props.disabled) return;
      if (active.value) return;
      api.goToItem(Focus.Specific, id);
    }

    function handleLeave() {
      if (props.disabled) return;
      if (!active.value) return;
      api.goToItem(Focus.Nothing);
    }

    return function () {
      var disabled = props.disabled;
      var slot = {
        active: active.value,
        disabled: disabled
      };
      var propsWeControl = {
        id: id,
        role: 'menuitem',
        tabIndex: disabled === true ? undefined : -1,
        'aria-disabled': disabled === true ? true : undefined,
        onClick: handleClick,
        onFocus: handleFocus,
        onPointermove: handleMove,
        onMousemove: handleMove,
        onPointerleave: handleLeave,
        onMouseleave: handleLeave
      };
      return render({
        props: _extends({}, props, propsWeControl),
        slot: slot,
        attrs: attrs,
        slots: slots,
        name: 'MenuItem'
      });
    };
  }
});

export { Menu, MenuButton, MenuItem, MenuItems };
//# sourceMappingURL=menu.esm.js.map
