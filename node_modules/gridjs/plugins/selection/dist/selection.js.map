{"version":3,"file":"selection.js","sources":["../src/rowSelection/store.ts","../src/rowSelection/actions.ts","../src/rowSelection/rowSelection.tsx"],"sourcesContent":["import { BaseStore } from 'gridjs';\nimport { RowSelectionActionsType } from './actions';\n\nexport type RowSelectionStoreState = {\n  rowIds: string[];\n};\n\nexport class RowSelectionStore extends BaseStore<\n  RowSelectionStoreState,\n  RowSelectionActionsType\n> {\n  getInitialState(): RowSelectionStoreState {\n    return { rowIds: [] };\n  }\n\n  handle(type, payload): void {\n    if (type === 'CHECK') {\n      const { ROW_ID } = payload;\n      this.check(ROW_ID);\n    }\n\n    if (type === 'UNCHECK') {\n      const { ROW_ID } = payload;\n      this.uncheck(ROW_ID);\n    }\n  }\n\n  private check(rowId: string): void {\n    // rowId already exists\n    if (this.state.rowIds.indexOf(rowId) > -1) return;\n\n    this.setState({\n      rowIds: [rowId, ...this.state.rowIds],\n    });\n  }\n\n  private uncheck(rowId: string): void {\n    const index = this.state.rowIds.indexOf(rowId);\n\n    // rowId doesn't exist\n    if (index === -1) return;\n\n    const cloned = [...this.state.rowIds];\n    cloned.splice(index, 1);\n\n    this.setState({\n      rowIds: cloned,\n    });\n  }\n}\n","import { BaseActions } from 'gridjs';\n\nexport interface RowSelectionActionsType {\n  CHECK: {\n    ROW_ID: string;\n  };\n\n  UNCHECK: {\n    ROW_ID: string;\n  };\n}\n\nexport class RowSelectionActions extends BaseActions<RowSelectionActionsType> {\n  check(rowId: string): void {\n    this.dispatch('CHECK', {\n      ROW_ID: rowId,\n    });\n  }\n\n  uncheck(rowId: string): void {\n    this.dispatch('UNCHECK', {\n      ROW_ID: rowId,\n    });\n  }\n}\n","import { h } from 'gridjs';\nimport { RowSelectionStore, RowSelectionStoreState } from './store';\nimport { RowSelectionActions } from './actions';\nimport { className } from 'gridjs';\nimport { Row } from 'gridjs';\nimport { PluginBaseComponent, PluginBaseProps } from 'gridjs';\nimport { Cell } from 'gridjs';\n\ninterface RowSelectionState {\n  isChecked: boolean;\n}\n\ninterface RowSelectionProps {\n  // row identifier\n  id: (row: Row) => string;\n  // it's optional because thead doesn't have a row\n  row?: Row;\n  cell?: Cell;\n  store?: RowSelectionStore;\n  selectedClassName?: string;\n  checkboxClassName?: string;\n}\n\nexport class RowSelection extends PluginBaseComponent<\n  RowSelectionProps & PluginBaseProps<RowSelection>,\n  RowSelectionState\n> {\n  private readonly actions: RowSelectionActions;\n  private readonly store: RowSelectionStore;\n  private readonly storeUpdatedFn: (...args) => void;\n\n  private isDataCell = (props): boolean => props.row !== undefined;\n  private getParentTR = (): Element =>\n    this.base &&\n    this.base.parentElement &&\n    (this.base.parentElement.parentElement as Element);\n\n  static defaultProps = {\n    selectedClassName: className('tr', 'selected'),\n    checkboxClassName: className('checkbox'),\n  };\n\n  constructor(\n    props: RowSelectionProps & PluginBaseProps<RowSelection>,\n    context,\n  ) {\n    super(props, context);\n\n    this.state = {\n      isChecked: false,\n    };\n\n    // store/dispatcher is required only if we are rendering a TD (not a TH)\n    if (this.isDataCell(props)) {\n      // create a new store if a global store doesn't exist\n      if (!props.store) {\n        const store = new RowSelectionStore(this.config.dispatcher);\n        this.store = store;\n\n        // to reuse for other checkboxes\n        props.plugin.props.store = store;\n      } else {\n        // restore the existing store\n        this.store = props.store;\n      }\n\n      this.actions = new RowSelectionActions(this.config.dispatcher);\n      this.storeUpdatedFn = this.storeUpdated.bind(this);\n      this.store.on('updated', this.storeUpdatedFn);\n\n      // also mark this checkbox as checked if cell.data is true\n      if (props.cell.data) {\n        this.check();\n      }\n    }\n  }\n\n  componentWillUnmount(): void {\n    this.store.off('updated', this.storeUpdatedFn);\n  }\n\n  componentDidMount(): void {\n    if (this.store) this.storeUpdated(this.store.state);\n  }\n\n  private storeUpdated(state: RowSelectionStoreState): void {\n    const parent = this.getParentTR();\n\n    if (!parent) return;\n\n    const isChecked = state.rowIds.indexOf(this.props.id(this.props.row)) > -1;\n\n    this.setState({\n      isChecked: isChecked,\n    });\n\n    if (isChecked) {\n      parent.classList.add(this.props.selectedClassName);\n    } else {\n      parent.classList.remove(this.props.selectedClassName);\n    }\n  }\n\n  private check(): void {\n    this.actions.check(this.props.id(this.props.row));\n    this.props.cell.update(true);\n  }\n\n  private uncheck(): void {\n    this.actions.uncheck(this.props.id(this.props.row));\n    this.props.cell.update(false);\n  }\n\n  private toggle(): void {\n    if (this.state.isChecked) {\n      this.uncheck();\n    } else {\n      this.check();\n    }\n  }\n\n  render() {\n    if (this.isDataCell(this.props)) {\n      return (\n        <input\n          type={'checkbox'}\n          checked={this.state.isChecked}\n          onChange={() => this.toggle()}\n          className={this.props.checkboxClassName}\n        />\n      );\n    }\n\n    return null;\n  }\n}\n"],"names":["RowSelectionStore","getInitialState","rowIds","handle","type","payload","this","check","ROW_ID","uncheck","rowId","state","indexOf","setState","index","cloned","splice","BaseStore","RowSelectionActions","dispatch","BaseActions","RowSelection","props","context","_this","actions","store","storeUpdatedFn","isDataCell","undefined","row","getParentTR","base","parentElement","isChecked","config","dispatcher","plugin","storeUpdated","bind","on","cell","data","componentWillUnmount","off","componentDidMount","parent","id","classList","add","selectedClassName","remove","update","toggle","render","checked","onChange","_this2","className","checkboxClassName","PluginBaseComponent","defaultProps"],"mappings":"4MAOaA,IAAAA,kGAIXC,gBAAA,WACE,MAAO,CAAEC,OAAQ,OAGnBC,OAAA,SAAOC,EAAMC,GACE,UAATD,GAEFE,KAAKC,MADcF,EAAXG,QAIG,YAATJ,GAEFE,KAAKG,QADcJ,EAAXG,WAKJD,MAAA,SAAMG,GAERJ,KAAKK,MAAMT,OAAOU,QAAQF,IAAU,GAExCJ,KAAKO,SAAS,CACZX,QAASQ,UAAUJ,KAAKK,MAAMT,aAI1BO,QAAA,SAAQC,GACd,IAAMI,EAAQR,KAAKK,MAAMT,OAAOU,QAAQF,GAGxC,IAAe,IAAXI,EAAJ,CAEA,IAAMC,YAAaT,KAAKK,MAAMT,QAC9Ba,EAAOC,OAAOF,EAAO,GAErBR,KAAKO,SAAS,CACZX,OAAQa,SAvCyBE,aCK1BC,kGACXX,MAAA,SAAMG,GACJJ,KAAKa,SAAS,QAAS,CACrBX,OAAQE,OAIZD,QAAA,SAAQC,GACNJ,KAAKa,SAAS,UAAW,CACvBX,OAAQE,QAT2BU,eCW5BC,cAmBX,WACEC,EACAC,SASA,IAPAC,cAAMF,EAAOC,UAnBEE,iBACAC,eACAC,wBAETC,WAAa,SAACN,eAAiCO,IAAdP,EAAMQ,OACvCC,YAAc,oBACfC,MACLR,EAAKQ,KAAKC,eACTT,EAAKQ,KAAKC,cAAcA,eAazBT,EAAKb,MAAQ,CACXuB,WAAW,GAITV,EAAKI,WAAWN,GAAQ,CAE1B,GAAKA,EAAMI,MAQTF,EAAKE,MAAQJ,EAAMI,UARH,CAChB,IAAMA,EAAQ,IAAI1B,EAAkBwB,EAAKW,OAAOC,YAChDZ,EAAKE,MAAQA,EAGbJ,EAAMe,OAAOf,MAAMI,MAAQA,EAM7BF,EAAKC,QAAU,IAAIP,EAAoBM,EAAKW,OAAOC,YACnDZ,EAAKG,eAAiBH,EAAKc,aAAaC,mIACxCf,EAAKE,MAAMc,GAAG,UAAWhB,EAAKG,gBAG1BL,EAAMmB,KAAKC,MACblB,EAAKjB,wBAjDb,2BAsDEoC,qBAAA,WACErC,KAAKoB,MAAMkB,IAAI,UAAWtC,KAAKqB,mBAGjCkB,kBAAA,WACMvC,KAAKoB,OAAOpB,KAAKgC,aAAahC,KAAKoB,MAAMf,UAGvC2B,aAAA,SAAa3B,GACnB,IAAMmC,EAASxC,KAAKyB,cAEpB,GAAKe,EAAL,CAEA,IAAMZ,EAAYvB,EAAMT,OAAOU,QAAQN,KAAKgB,MAAMyB,GAAGzC,KAAKgB,MAAMQ,OAAS,EAEzExB,KAAKO,SAAS,CACZqB,UAAWA,IAGTA,EACFY,EAAOE,UAAUC,IAAI3C,KAAKgB,MAAM4B,mBAEhCJ,EAAOE,UAAUG,OAAO7C,KAAKgB,MAAM4B,uBAI/B3C,MAAA,WACND,KAAKmB,QAAQlB,MAAMD,KAAKgB,MAAMyB,GAAGzC,KAAKgB,MAAMQ,MAC5CxB,KAAKgB,MAAMmB,KAAKW,QAAO,MAGjB3C,QAAA,WACNH,KAAKmB,QAAQhB,QAAQH,KAAKgB,MAAMyB,GAAGzC,KAAKgB,MAAMQ,MAC9CxB,KAAKgB,MAAMmB,KAAKW,QAAO,MAGjBC,OAAA,WACF/C,KAAKK,MAAMuB,UACb5B,KAAKG,UAELH,KAAKC,WAIT+C,OAAA,sBACE,OAAIhD,KAAKsB,WAAWtB,KAAKgB,oBAGnBlB,KAAM,WACNmD,QAASjD,KAAKK,MAAMuB,UACpBsB,SAAU,kBAAMC,EAAKJ,UACrBK,UAAWpD,KAAKgB,MAAMqC,6BAzGEC,uBAArBvC,EAcJwC,aAAe,CACpBX,kBAAmBQ,YAAU,KAAM,YACnCC,kBAAmBD,YAAU"}