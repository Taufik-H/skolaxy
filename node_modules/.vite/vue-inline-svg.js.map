{
  "version": 3,
  "sources": ["../vue-inline-svg/src/index.js", "dep:vue-inline-svg"],
  "sourcesContent": ["// peer dep is not installed during test\n// eslint-disable-next-line import/no-unresolved\nimport { h as createElement } from 'vue';\n\n/** @type Object{string: Promise<Element>} */\nconst cache = {};\n\n/**\n * Remove false attrs\n * @param {Object} attrs\n */\nfunction filterAttrs(attrs) {\n    return Object.keys(attrs).reduce((result, key) => {\n        if (attrs[key] !== false && attrs[key] !== null && attrs[key] !== undefined) {\n            result[key] = attrs[key];\n        }\n        return result;\n    }, {});\n}\n\nconst InlineSvg = {\n    name: 'InlineSvg',\n    inheritAttrs: false,\n    render() {\n        if (!this.svgElSource) {\n            return null;\n        }\n        return createElement(\n            'svg',\n            Object.assign(\n                {},\n                // source attrs\n                this.getSvgAttrs(this.svgElSource),\n                // component attrs and listeners\n                filterAttrs(this.$attrs),\n                // content\n                { innerHTML: this.getSvgContent(this.svgElSource) },\n            ),\n        );\n    },\n    props: {\n        src: {\n            type: String,\n            required: true,\n        },\n        title: {\n            type: String,\n        },\n        transformSource: {\n            type: Function,\n            default: (svg) => svg,\n        },\n        keepDuringLoading: {\n            type: Boolean,\n            default: true,\n        },\n    },\n    emits: ['loaded', 'unloaded', 'error'],\n    data() {\n        return {\n            /** @type SVGElement */\n            svgElSource: null,\n        };\n    },\n    watch: {\n        src(newValue) {\n            // re-generate cached svg (`svgElSource`)\n            this.getSource(newValue);\n        },\n    },\n    mounted() {\n        // generate `svgElSource`\n        this.getSource(this.src);\n    },\n    methods: {\n        getSvgAttrs(svgEl) {\n            // copy attrs\n            let svgAttrs = {};\n            const attrs = svgEl.attributes;\n            if (!attrs) {\n                return svgAttrs;\n            }\n            for (let i = attrs.length - 1; i >= 0; i--) {\n                svgAttrs[attrs[i].name] = attrs[i].value;\n            }\n            return svgAttrs;\n        },\n        getSvgContent(svgEl) {\n            svgEl = svgEl.cloneNode(true);\n            svgEl = this.transformSource(svgEl);\n            if (this.title) {\n                setTitle(svgEl, this.title);\n            }\n\n            // copy inner html\n            return svgEl.innerHTML;\n        },\n        /**\n         * Get svgElSource\n         * @param {string} src\n         */\n        getSource(src) {\n            // fill cache by src with promise\n            if (!cache[src]) {\n                // download\n                cache[src] = this.download(src);\n            }\n            // notify svg is unloaded\n            if (this.svgElSource && cache[src].isPending() && !this.keepDuringLoading) {\n                this.svgElSource = null;\n                this.$emit('unloaded');\n            }\n\n            // inline svg when cached promise resolves\n            cache[src]\n                .then((svg) => {\n                    this.svgElSource = svg;\n                    // wait to render\n                    this.$nextTick(() => {\n                        // notify\n                        this.$emit('loaded', this.$el);\n                    });\n                })\n                .catch((err) => {\n                    // notify svg is unloaded\n                    if (this.svgElSource) {\n                        this.svgElSource = null;\n                        this.$emit('unloaded');\n                    }\n                    // remove cached rejected promise so next image can try load again\n                    delete cache[src];\n                    this.$emit('error', err);\n                });\n        },\n\n        /**\n         * Get the contents of the SVG\n         * @param {string} url\n         * @returns {Promise<Element>}\n         */\n        download(url) {\n            return makePromiseState(new Promise((resolve, reject) => {\n                const request = new XMLHttpRequest();\n                request.open('GET', url, true);\n\n                request.onload = () => {\n                    if (request.status >= 200 && request.status < 400) {\n                        try {\n                            // Setup a parser to convert the response to text/xml in order for it to be manipulated and changed\n                            const parser = new DOMParser();\n                            const result = parser.parseFromString(request.responseText, 'text/xml');\n                            let svgEl = result.getElementsByTagName('svg')[0];\n                            if (svgEl) {\n                                // svgEl = this.transformSource(svgEl);\n                                resolve(svgEl);\n                            } else {\n                                reject(new Error('Loaded file is not valid SVG\"'));\n                            }\n                        } catch (e) {\n                            reject(e);\n                        }\n                    } else {\n                        reject(new Error('Error loading SVG'));\n                    }\n                };\n\n                request.onerror = reject;\n                request.send();\n            }));\n        },\n    },\n};\n\n/**\n * Create or edit the <title> element of a SVG\n * @param {SVGElement} svg\n * @param {string} title\n */\nfunction setTitle(svg, title) {\n    const titleTags = svg.getElementsByTagName('title');\n    if (titleTags.length) { // overwrite existing title\n        titleTags[0].textContent = title;\n    } else { // create a title element if one doesn't already exist\n        const titleEl = document.createElementNS('http://www.w3.org/2000/svg', 'title');\n        titleEl.textContent = title;\n        svg.appendChild(titleEl);\n    }\n}\n\n/**\n * @typedef {Promise} PromiseWithState\n * @property {Function<boolean>} isPending\n */\n\n/**\n * This function allow you to modify a JS Promise by adding some status properties.\n * @param {Promise|PromiseWithState} promise\n * @return {PromiseWithState}\n */\nfunction makePromiseState(promise) {\n    // Don't modify any promise that has been already modified.\n    if (promise.isPending) return promise;\n\n    // Set initial state\n    let isPending = true;\n\n    // Observe the promise, saving the fulfillment in a closure scope.\n    let result = promise.then(\n        (v) => {\n            isPending = false;\n            return v;\n        },\n        (e) => {\n            isPending = false;\n            throw e;\n        },\n    );\n\n    result.isPending = function getIsPending() { return isPending; };\n    return result;\n}\n\nexport default InlineSvg;\n", "import d from \"./node_modules/vue-inline-svg/src/index.js\";export default d;"],
  "mappings": ";;;;;;;AAEA;AAGA,IAAM,QAAQ;AAMd,qBAAqB,OAAO;AACxB,SAAO,OAAO,KAAK,OAAO,OAAO,CAAC,QAAQ,QAAQ;AAC9C,QAAI,MAAM,SAAS,SAAS,MAAM,SAAS,QAAQ,MAAM,SAAS,QAAW;AACzE,aAAO,OAAO,MAAM;AAAA;AAExB,WAAO;AAAA,KACR;AAAA;AAGP,IAAM,YAAY;AAAA,EACd,MAAM;AAAA,EACN,cAAc;AAAA,EACd,SAAS;AACL,QAAI,CAAC,KAAK,aAAa;AACnB,aAAO;AAAA;AAEX,WAAO,EACH,OACA,OAAO,OACH,IAEA,KAAK,YAAY,KAAK,cAEtB,YAAY,KAAK,SAEjB,EAAE,WAAW,KAAK,cAAc,KAAK;AAAA;AAAA,EAIjD,OAAO;AAAA,IACH,KAAK;AAAA,MACD,MAAM;AAAA,MACN,UAAU;AAAA;AAAA,IAEd,OAAO;AAAA,MACH,MAAM;AAAA;AAAA,IAEV,iBAAiB;AAAA,MACb,MAAM;AAAA,MACN,SAAS,CAAC,QAAQ;AAAA;AAAA,IAEtB,mBAAmB;AAAA,MACf,MAAM;AAAA,MACN,SAAS;AAAA;AAAA;AAAA,EAGjB,OAAO,CAAC,UAAU,YAAY;AAAA,EAC9B,OAAO;AACH,WAAO;AAAA,MAEH,aAAa;AAAA;AAAA;AAAA,EAGrB,OAAO;AAAA,IACH,IAAI,UAAU;AAEV,WAAK,UAAU;AAAA;AAAA;AAAA,EAGvB,UAAU;AAEN,SAAK,UAAU,KAAK;AAAA;AAAA,EAExB,SAAS;AAAA,IACL,YAAY,OAAO;AAEf,UAAI,WAAW;AACf,YAAM,QAAQ,MAAM;AACpB,UAAI,CAAC,OAAO;AACR,eAAO;AAAA;AAEX,eAAS,IAAI,MAAM,SAAS,GAAG,KAAK,GAAG,KAAK;AACxC,iBAAS,MAAM,GAAG,QAAQ,MAAM,GAAG;AAAA;AAEvC,aAAO;AAAA;AAAA,IAEX,cAAc,OAAO;AACjB,cAAQ,MAAM,UAAU;AACxB,cAAQ,KAAK,gBAAgB;AAC7B,UAAI,KAAK,OAAO;AACZ,iBAAS,OAAO,KAAK;AAAA;AAIzB,aAAO,MAAM;AAAA;AAAA,IAMjB,UAAU,KAAK;AAEX,UAAI,CAAC,MAAM,MAAM;AAEb,cAAM,OAAO,KAAK,SAAS;AAAA;AAG/B,UAAI,KAAK,eAAe,MAAM,KAAK,eAAe,CAAC,KAAK,mBAAmB;AACvE,aAAK,cAAc;AACnB,aAAK,MAAM;AAAA;AAIf,YAAM,KACD,KAAK,CAAC,QAAQ;AACX,aAAK,cAAc;AAEnB,aAAK,UAAU,MAAM;AAEjB,eAAK,MAAM,UAAU,KAAK;AAAA;AAAA,SAGjC,MAAM,CAAC,QAAQ;AAEZ,YAAI,KAAK,aAAa;AAClB,eAAK,cAAc;AACnB,eAAK,MAAM;AAAA;AAGf,eAAO,MAAM;AACb,aAAK,MAAM,SAAS;AAAA;AAAA;AAAA,IAShC,SAAS,KAAK;AACV,aAAO,iBAAiB,IAAI,QAAQ,CAAC,SAAS,WAAW;AACrD,cAAM,UAAU,IAAI;AACpB,gBAAQ,KAAK,OAAO,KAAK;AAEzB,gBAAQ,SAAS,MAAM;AACnB,cAAI,QAAQ,UAAU,OAAO,QAAQ,SAAS,KAAK;AAC/C,gBAAI;AAEA,oBAAM,SAAS,IAAI;AACnB,oBAAM,SAAS,OAAO,gBAAgB,QAAQ,cAAc;AAC5D,kBAAI,QAAQ,OAAO,qBAAqB,OAAO;AAC/C,kBAAI,OAAO;AAEP,wBAAQ;AAAA,qBACL;AACH,uBAAO,IAAI,MAAM;AAAA;AAAA,qBAEhB,GAAP;AACE,qBAAO;AAAA;AAAA,iBAER;AACH,mBAAO,IAAI,MAAM;AAAA;AAAA;AAIzB,gBAAQ,UAAU;AAClB,gBAAQ;AAAA;AAAA;AAAA;AAAA;AAWxB,kBAAkB,KAAK,OAAO;AAC1B,QAAM,YAAY,IAAI,qBAAqB;AAC3C,MAAI,UAAU,QAAQ;AAClB,cAAU,GAAG,cAAc;AAAA,SACxB;AACH,UAAM,UAAU,SAAS,gBAAgB,8BAA8B;AACvE,YAAQ,cAAc;AACtB,QAAI,YAAY;AAAA;AAAA;AAcxB,0BAA0B,SAAS;AAE/B,MAAI,QAAQ;AAAW,WAAO;AAG9B,MAAI,YAAY;AAGhB,MAAI,SAAS,QAAQ,KACjB,CAAC,MAAM;AACH,gBAAY;AACZ,WAAO;AAAA,KAEX,CAAC,MAAM;AACH,gBAAY;AACZ,UAAM;AAAA;AAId,SAAO,YAAY,wBAAwB;AAAE,WAAO;AAAA;AACpD,SAAO;AAAA;AAGX,IAAO,cAAQ;;;AC9N4C,IAAO,yBAAQ;",
  "names": []
}
